//
//  LexerMicro.ino
//

#include <stdint.h>
#include <OctoWS2811.h>

#define STATION_ID      (0)

#define LEDS_PER_STRIP  (76)
#define LED_COUNT       (LEDS_PER_STRIP * 3)

#include "attract.h"
#include "computer.h"

#define SERIAL_FORMAT   (SERIAL_8N1)
#define USB             Serial
#define RINGSERIAL      Serial1
#define RING_TX         (1)
#define RING_RX         (0)

#define LEVEL_SHIFTER_OE_PIN   (3)

#define ATTRACT_ANIM_MILLIS_MIN    (11000)
#define ATTRACT_ANIM_MILLIS_MAX    (15000)
#define ACTIVE_USER_TIMEOUT_MILLIS (120000)

int BLINK_PIN = 13;
uint8_t frameCount = 0;
uint8_t blinkCount = 0;

int LED_STRIP_PIN = 17;	// Teensy LC
DMAMEM int displayMemory[LEDS_PER_STRIP * 6];
int drawingMemory[LEDS_PER_STRIP * 6];
const int config = WS2811_RBG | WS2811_800kHz;
OctoWS2811 leds(LEDS_PER_STRIP, displayMemory, drawingMemory, config);

unsigned long lastMillis = 0;
//uint16_t millisSinceSensor = ULTRASONIC_INTERVAL_MS;

// Arduino Uno: 19200 baud works, 57600 definitely does not.
const int BAUD_RATE = 9600;

/*
int16_t attractIndex = -1;
int32_t millisUntilAttract = ATTRACT_ANIM_MILLIS_MIN;
*/

/*
void run_attract_string(const char * str, const uint8_t lifespan)
{
	bool sendLifespan = true;

	while ((*str) != '\0') {
		if (sendLifespan) {
			computer_input_from_upstream('0' + lifespan);
			sendLifespan = false;
		}

		char ch = (*str);
		if (ch == '\n') {
			sendLifespan = true;
		}

		computer_input_from_upstream(ch);

		// Advance to next character
		str++;
	}
}
*/

void run_attract_string_with_lifespan_bytes_in_it(const char * str) {
	while ((*str) != '\0') {
		char ch = (*str);
		computer_input_from_usb(ch);
		str++;
	}
}

void test_serial_string(String str)
{
	for (uint8_t i = 0; i < str.length(); i++) {
		computer_input_from_upstream(str.charAt(i));
	}
}

void serial_input(uint8_t b, bool isUsb) {
	LineResult result;

	if (isUsb) {
		result = computer_input_from_usb(b);
	} else {
		result = computer_input_from_upstream(b);
	}

	//Serial.println(result);

	if ((result == k_line_ok) || (result == k_line_end)) {
		// Pass the data along, downstream.
		RINGSERIAL.write(b);

	} else if (result == k_line_first_byte) {
		if (('1' <= b) && (b <= '9')) {
			// Message lifespan: Decrement and pass onward
			RINGSERIAL.write(b - 1);
		}
	}
}

// the setup routine runs once when you press reset:
void setup() {
	// USB to computer
	USB.begin(BAUD_RATE);

	pinMode(LEVEL_SHIFTER_OE_PIN, OUTPUT);
	digitalWrite(LEVEL_SHIFTER_OE_PIN, LOW);

	RINGSERIAL.setTX(RING_TX);
	RINGSERIAL.setRX(RING_RX);
	RINGSERIAL.begin(BAUD_RATE, SERIAL_FORMAT);

	// initialize the digital pin as an output.
	pinMode(BLINK_PIN, OUTPUT);

	leds.begin();
	leds.show();

	computer_init(&leds);

	lastMillis = millis();

	// Appliance mode: Automatically run an animation
	// when switched on.
	// FIXME: Put these in an array. Arrays of char *
	// are behaving badly, I'm in the hot sun and I'm over it

	switch (STATION_ID) {

		case 0: {run_attract_string_with_lifespan_bytes_in_it(
			"\x31\x63\x21\x0a\x31\x67\x43\x7f\x0a\x31\x73\x21\x2a\x54\x5f\x2c\x31\x0a\x31\x73\x22\x2a\x50\x5f\x2c\x32\x35\x0a\x31\x73\x23\x2d\x76\x21\x2c\x76\x22\x0a\x31\x73\x24\x2e\x76\x23\x0a\x31\x73\x25\x2d\x31\x2c\x76\x24\x0a\x31\x73\x26\x2a\x76\x25\x2c\x76\x25\x0a\x31\x73\x27\x2a\x76\x26\x2c\x76\x26\x0a\x31\x73\x28\x2d\x31\x2c\x76\x27\x0a\x31\x73\x29\x5a\x30\x2e\x39\x2c\x31\x0a\x31\x73\x2a\x2a\x76\x25\x2c\x76\x29\x0a\x31\x73\x2b\x2a\x76\x2a\x2c\x30\x2e\x32\x35\x0a\x31\x73\x2c\x71\x76\x2b\x0a\x31\x73\x2d\x2a\x54\x5f\x2c\x30\x2e\x30\x32\x0a\x31\x73\x2e\x5d\x76\x2d\x2c\x76\x28\x2c\x76\x2c\x0a\x31\x63\x2f\x0a"
		); break;}

		case 1: {run_attract_string_with_lifespan_bytes_in_it(
			"\x31\x63\x21\x0a\x31\x67\x47\x7f\x0a\x31\x73\x21\x2a\x41\x5f\x2c\x35\x0a\x31\x73\x22\x2a\x54\x5f\x2c\x30\x2e\x39\x0a\x31\x73\x23\x2b\x76\x21\x2c\x76\x22\x0a\x31\x73\x24\x2a\x54\x5f\x2c\x30\x2e\x32\x0a\x31\x73\x25\x2b\x76\x23\x2c\x76\x24\x0a\x31\x73\x26\x2e\x76\x25\x0a\x31\x73\x27\x6c\x30\x2e\x39\x35\x2c\x30\x2e\x35\x2c\x76\x26\x0a\x31\x73\x28\x32\x58\x5f\x2c\x59\x5f\x0a\x31\x73\x29\x2a\x76\x28\x2c\x30\x2e\x32\x0a\x31\x73\x2a\x2b\x76\x27\x2c\x76\x29\x0a\x31\x73\x2b\x5d\x76\x2a\x2c\x31\x2c\x31\x0a\x31\x63\x2c\x0a"
		); break;}

		// Wheel with noise spokes
		case 2: {run_attract_string_with_lifespan_bytes_in_it(
			"\x31\x63\x21\x0a\x31\x67\x43\x7f\x0a\x31\x73\x21\x2a\x54\x5f\x2c\x30\x2e\x39\x0a\x31\x73\x22\x2a\x41\x5f\x2c\x35\x0a\x31\x73\x23\x2d\x76\x22\x2c\x76\x21\x0a\x31\x73\x24\x73\x76\x23\x0a\x31\x73\x25\x2a\x76\x24\x2c\x76\x24\x0a\x31\x73\x26\x2a\x76\x24\x2c\x76\x25\x0a\x31\x73\x27\x2d\x31\x2c\x76\x26\x0a\x31\x73\x28\x2a\x59\x5f\x2c\x32\x38\x0a\x31\x73\x29\x2a\x58\x5f\x2c\x39\x0a\x31\x73\x2a\x2b\x76\x29\x2c\x76\x28\x0a\x31\x73\x2b\x2e\x76\x2a\x0a\x31\x73\x2c\x6c\x30\x2e\x37\x2c\x31\x2c\x76\x2b\x0a\x31\x73\x2d\x2a\x76\x24\x2c\x76\x2c\x0a\x31\x73\x2e\x2a\x54\x5f\x2c\x30\x2e\x30\x33\x0a\x31\x73\x2f\x5d\x76\x2e\x2c\x76\x27\x2c\x76\x2d\x0a\x31\x63\x30\x0a"
		); break;}

		// Fast matrix tracers
		case 3: {run_attract_string_with_lifespan_bytes_in_it(
			"\x31\x63\x21\x0a\x31\x67\x43\x7f\x0a\x31\x73\x21\x2a\x54\x5f\x2c\x31\x2e\x35\x0a\x31\x73\x22\x2a\x50\x5f\x2c\x31\x30\x0a\x31\x73\x23\x2d\x76\x21\x2c\x76\x22\x0a\x31\x73\x24\x2e\x76\x23\x0a\x31\x73\x25\x2d\x31\x2c\x76\x24\x0a\x31\x73\x26\x2a\x76\x25\x2c\x76\x25\x0a\x31\x73\x27\x2a\x76\x26\x2c\x76\x26\x0a\x31\x73\x28\x2d\x31\x2c\x76\x27\x0a\x31\x73\x29\x5a\x30\x2e\x39\x2c\x31\x0a\x31\x73\x2a\x2a\x76\x25\x2c\x76\x29\x0a\x31\x73\x2b\x2a\x76\x2a\x2c\x30\x2e\x32\x35\x0a\x31\x73\x2c\x71\x76\x2b\x0a\x31\x73\x2d\x2a\x54\x5f\x2c\x30\x2e\x30\x32\x0a\x31\x73\x2e\x5d\x76\x2d\x2c\x76\x28\x2c\x76\x2c\x0a\x31\x63\x2f\x0a"
		); break;}

		// Color pinwheel
		case 4: {run_attract_string_with_lifespan_bytes_in_it(
"\x31\x63\x21\x0a\x31\x67\x47\x7f\x0a\x31\x73\x21\x2a\x41\x5f\x2c\x31\x0a\x31\x73\x22\x2b\x76\x21\x2c\x54\x5f\x0a\x31\x73\x23\x2e\x76\x22\x0a\x31\x73\x24\x5d\x76\x23\x2c\x31\x2c\x31\x0a\x31\x63\x25\x0a"
		); break;}

		// Atari color cycling
		case 5: {run_attract_string_with_lifespan_bytes_in_it(
"\x31\x63\x21\x0a\x31\x67\x43\x7f\x0a\x31\x73\x21\x2a\x59\x5f\x2c\x39\x39\x0a\x31\x73\x22\x2a\x58\x5f\x2c\x76\x21\x0a\x31\x73\x23\x2a\x59\x5f\x2c\x39\x37\x0a\x31\x73\x24\x2a\x59\x5f\x2c\x76\x23\x0a\x31\x73\x25\x2a\x59\x5f\x2c\x76\x24\x0a\x31\x73\x26\x32\x76\x22\x2c\x76\x25\x0a\x31\x73\x27\x2a\x54\x5f\x2c\x31\x0a\x31\x73\x28\x2a\x76\x26\x2c\x33\x0a\x31\x73\x29\x2b\x76\x28\x2c\x76\x27\x0a\x31\x73\x2a\x74\x76\x29\x0a\x31\x73\x2b\x25\x76\x29\x2c\x31\x36\x0a\x31\x73\x2c\x5f\x76\x2b\x0a\x31\x73\x2d\x2f\x76\x2c\x2c\x31\x36\x0a\x31\x73\x2e\x6c\x31\x2c\x30\x2e\x36\x2c\x76\x2a\x0a\x31\x73\x2f\x3d\x76\x2d\x0a\x31\x73\x30\x3f\x76\x2f\x2c\x30\x2c\x76\x2e\x0a\x31\x73\x31\x5d\x76\x2d\x2c\x76\x30\x2c\x76\x2a\x0a\x31\x63\x32\x0a"
		); break;}

		// Pride flag (rainbow)
		case 6: {run_attract_string_with_lifespan_bytes_in_it(
"\x31\x63\x21\x0a\x31\x67\x47\x7f\x0a\x31\x73\x21\x2a\x58\x5f\x2c\x32\x2e\x32\x0a\x31\x73\x22\x2a\x54\x5f\x2c\x31\x2e\x33\x0a\x31\x73\x23\x2b\x76\x22\x2c\x76\x21\x0a\x31\x73\x24\x71\x76\x23\x0a\x31\x73\x25\x2a\x58\x5f\x2c\x31\x2e\x34\x31\x34\x0a\x31\x73\x26\x2a\x54\x5f\x2c\x30\x2e\x37\x0a\x31\x73\x27\x2b\x76\x26\x2c\x76\x25\x0a\x31\x73\x28\x71\x76\x27\x0a\x31\x73\x29\x2d\x76\x24\x2c\x76\x28\x0a\x31\x73\x2a\x2a\x76\x29\x2c\x30\x2e\x30\x39\x0a\x31\x73\x2b\x2b\x59\x5f\x2c\x76\x2a\x0a\x31\x73\x2c\x2a\x76\x2b\x2c\x36\x0a\x31\x73\x2d\x5f\x76\x2c\x0a\x31\x73\x2e\x2f\x76\x2d\x2c\x36\x0a\x31\x73\x2f\x78\x76\x2e\x2c\x30\x2c\x30\x2e\x38\x33\x33\x33\x33\x0a\x31\x73\x30\x3c\x76\x2f\x2c\x30\x2e\x36\x0a\x31\x73\x31\x2d\x76\x2f\x2c\x30\x2e\x31\x36\x36\x36\x36\x37\x0a\x31\x73\x32\x3f\x76\x30\x2c\x76\x31\x2c\x76\x2f\x0a\x31\x73\x33\x3c\x76\x32\x2c\x30\x2e\x32\x0a\x31\x73\x34\x2b\x76\x32\x2c\x30\x2e\x31\x36\x36\x36\x36\x37\x0a\x31\x73\x35\x2f\x76\x34\x2c\x32\x0a\x31\x73\x36\x3f\x76\x33\x2c\x76\x35\x2c\x76\x32\x0a\x31\x73\x37\x5d\x76\x36\x2c\x31\x2c\x31\x0a\x31\x63\x38\x0a"
		); break;}

		case 7: {run_attract_string_with_lifespan_bytes_in_it(
			// Purple radiation from upper-left corner
			"\x37\x63\x21\x0a\x37\x67\x43\x7f\x0a\x37\x73\x21\x2a\x58\x5f\x2c\x58\x5f\x0a\x37\x73\x22\x2a\x59\x5f\x2c\x59\x5f\x0a\x37\x73\x23\x2b\x76\x21\x2c\x76\x22\x0a\x37\x73\x24\x2a\x76\x23\x2c\x33\x2e\x33\x0a\x37\x73\x25\x2a\x54\x5f\x2c\x30\x2e\x34\x35\x0a\x37\x73\x26\x2d\x76\x24\x2c\x76\x25\x0a\x37\x73\x27\x71\x76\x26\x0a\x37\x73\x28\x5a\x30\x2c\x30\x2e\x30\x31\x0a\x37\x73\x29\x30\x76\x28\x0a\x37\x73\x2a\x71\x76\x29\x0a\x37\x73\x2b\x6c\x30\x2e\x38\x2c\x31\x2c\x76\x2a\x0a\x37\x73\x2c\x2a\x54\x5f\x2c\x30\x2e\x30\x33\x0a\x37\x73\x2d\x74\x76\x2c\x0a\x37\x73\x2e\x6c\x30\x2e\x37\x35\x2c\x30\x2e\x39\x31\x36\x36\x36\x37\x2c\x76\x2d\x0a\x37\x73\x2f\x5d\x76\x2e\x2c\x76\x2b\x2c\x76\x27\x0a\x37\x63\x30\x0a"
		); break;}
	}

}

// the loop routine runs over and over again forever:
void loop() {
	leds.show();

	unsigned long now = millis();
	uint16_t elapsed = now - lastMillis;
	lastMillis = now;

	// User input: disables attract mode, for a little while
	// 2018-06-22: At Toorcamp. Disabling attract, for now.
	/*
	if (STATION_ID == 0) {
		if ((USB.available() > 0) || (RINGSERIAL.available() > 0)) {
			millisUntilAttract = ACTIVE_USER_TIMEOUT_MILLIS;
		}

		// New attract mode?
		millisUntilAttract -= elapsed;
		if (millisUntilAttract <= 0) {
			millisUntilAttract = lerp(ATTRACT_ANIM_MILLIS_MIN, ATTRACT_ANIM_MILLIS_MAX, randf());

			// FIXME: array length
			attractIndex = (attractIndex + 1) % ATTRACT_MODES_LEN;

			run_attract_string(ATTRACT_MODES[attractIndex], STATION_COUNT - 1);
			//run_attract_string(TEST, 7);
		}
	}
	*/

	// From Serial: From the laptop/programmer
	while (USB.available() > 0) {
		// read the incoming byte:
		uint8_t b = Serial.read();
		serial_input(b, true);
	}

	// From UPSTREAM: From the microprocessor 1 higher
	while (RINGSERIAL.available() > 0) {
		// read the incoming byte:
		uint8_t b = RINGSERIAL.read();
		serial_input(b, false);
	}

	computer_run(elapsed);

	// Blink to prove we're alive.
	// Blinks once every 60 frames. If blink rate is >1/sec, frame rate is good!
	frameCount = (frameCount + 1) % 60;
	if (frameCount == 0) blinkCount++;

	BlinkType bt = computer_get_blink_type();

	switch (bt) {
		case k_blink_60th_frame:
		case k_blink_station_id:
		{
			int state = (frameCount == 0) ? HIGH : LOW;

			if ((state == HIGH) && (bt == k_blink_station_id)) {
				state = ((blinkCount & 0x7) <= computer_get_station_id()) ? HIGH : LOW;
			}

			digitalWrite(BLINK_PIN, state);
		}
		break;

		case k_blink_off:
		{
			digitalWrite(BLINK_PIN, LOW);
		}
		break;

		case k_blink_on:
		{
			digitalWrite(BLINK_PIN, HIGH);
		}
		break;
	}
}
